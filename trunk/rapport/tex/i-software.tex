\chapter[Implementering af software]{Software}

% Note om hvad der skal stå i dette afsnit her.


\section{Oversigt over softwaren}
\mnote{Kristian Kjærgaard}

% Her skriver vi hvordan softwaren er struktureret - se figuren nedenfor.

Softwaren er struktureret som vist i
figur\vref{fig:software-oversigt}. Dataføderen leverer data til den
del af softwaren, der behandler HPGL. Dataen kommer fra et
SD-kort. HPGL-behandleren sender instruktioner videre til den del af
motorkontrollen, der afvikles, når der er tid. Denne del sætter
instruktioner i kø til realtidsdelen.

Realtidsdelen af motorkontrollen behandler de instruktioner, den anden
del af motorkontrollen har sat i kø og styrer stepmotorer m.m. efter
disse instruktioner. Realtidsdelen af motorkontrollen har ansvar for,
at hastigheden af tegnehovedet kan styres præcist.


\begin{figure}[htbp]
  \centering
  \includegraphics[width=.75\textwidth]{../brugere/kjaergaard/software-oversigt}
  \caption{Oversigt over softwaren. De lyseblå dele afvikles, når der
    er tid til det. Når det er tid til at afvikle de mørkeblå områder,
    afbrydes afviklingen af de lyseblå.}
  \label{fig:software-oversigt}
\end{figure}


\section[Dataføder (med SPI og SD-/MMC-kort)]{Dataføder}

% Hvordan virker dataføderen (herunder buffer, spi og sd/mmc)?

Dataføderen leverer data til HPGL-motoren og håndterer de
underliggende moduler, der indeholder data.

Dataføderen skal;
\begin{itemize} \firmlist
\item levere data til HPGL-behandleren og sørge for at denne ikke løber
  tør for data.
\item stille et ensartet API\footnote{Application Programming
    Interface, programmeringsbrugerflade; betegnelse for struktur og
    navngivning for funktioner, variable, strukturer, klasser
    etc. brugt til programudvikling.} til rådighed uafhængig af
  underliggende modul, således at det overliggende modul er uafhængig
  af det modul, der indeholder data - se
  figur\vref{fig:datafeeder-uniform-api}.
\item håndtere fejl for underliggende moduler.
\end{itemize}

\mnote{
  \includegraphics[width=\marginparwidth]{../brugere/kjaergaard/datafoeder-uniform-api}
  \captionof{figure}{Data\-føderen skal stille et ensartet API til
    rådighed.}
  \label{fig:datafeeder-uniform-api}
}

Kommunikationen med SD-kortet foregår gennem SPI'en\footnote{Serial
  Peripheral Interface, en seriel indgang til MCU'en}, hvor der sendes
én byte og modtages én byte synkront. I SD-motoren deles forespørgslen
med parametre op i bytes, som sendes en ad gangen. SD-kortet svarer
med bytes, som sættes sammen til et forståeligt svar. SPI'en bruges
som vært, så for hver sendt byte skal der modtages en, og inden en
byte kan modtages, skal der sendes en byte. Se
figur\vref{fig:software-spi-sd-handling}.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{../brugere/kjaergaard/datafeeder-handling}
  \caption{Forespørgsel til SD-kortet. Der forespørges på et
    hukommelsesområde, og SD-kortet svarer med det hukommelsesområde.}
  \label{fig:software-spi-sd-handling}
\end{figure}


Softwaren til at styre SD-kortet og SPI-en er skrevet af Roland
Riegel, se~\cite{bbt:sd-software}.


\section{HPGL-behandleren}

\mnote{Christian Klim Hansen}

% Hvordan virker den del, der fortolker og behandler HPGL?
HPGL er et dataformat, som indeholder adskillige forskellige
instruktioner med forskellige parametre (se
afsnit\vref{sc:idn-ins-param}) . Vi benytter os ikke af samtlige
instruktioner, men blot et lille udvalg med udgangspunkt i vores
kravspecifikation. I projektet anvender vi følgende instruktioner:

\begin{itemize} \firmlist
\item \texttt{PU} Pen Up - bruges til at hæve
\item \texttt{PD} Pen Down - bruges til at sænke pennen
\item \texttt{PA} Plot Absolut - se afsnit~\vref{sc:relativ-absolut}
\item \texttt{PR} Plot Relative
\item \texttt{CI} Plot Circle - se afsnit~\vref{sc:matematik-cirkel}.
\end{itemize}


HPGL-formatet kan læses med en teksteditor. Formatet består af
instruktioner, hvoraf de fleste har talparametre, enkelte har
ét-bytes-parametre, og nogle ingen parametre har. En instruktion kan
bestå af to store bogstaver (A-Z), og en talparameter består af tal og
punktum. Komma eller mellemrum adskiller parametrene, og semikolon
adskiller sidste parameter i en instruktion fra næste instruktion
(denne separator er ikke obligatorisk). Se figur\vref{fig:hpgl-syntaks}.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=.4\textwidth]{./img/hpgl-syntaks}
  \caption{HPGL-syntaks}
  \label{fig:hpgl-syntaks}
\end{figure}


\subsection{Identifikation af instruktioner og parametre}
\label{sc:idn-ins-param}
\mnote{Kristian Kjærgaard}
% Her skriver vi hvordan vi identificerer instruktioner og parametre i
% datastrømmen

HPGL-behandleren identificerer instruktioner og parametre på
datastrømmen med en \textit{parser}. Databehandleren består af en
markør og pladsholdere til instruktioner og parametre.

Parseren er \textit{byte}-orienteret og kan kun se én byte ad gangen,
se figur\vref{fig:hpgl-parser-iden}. Afhængig af denne bytes værdi
gemmer parseren byten i en pladsholder og indlæser den næste byte for
at sætte kæden sammen til instruktioner eller parametre til
instruktioner.

% floaten ligger muligvis for lavt
\snote{
  \includegraphics[width=\marginparwidth]{../brugere/kjaergaard/datafoeder}
  \captionof{figure}{Markøren på datastrømmen i HPGL-behandlerens
    identifikation af instruktioner på datastrømmen}
  \label{fig:hpgl-parser-iden}
}

Hvis byten ikke har en værdi, parseren forstår, flyttes markøren
videre til næste byte, således at den byte, markøren peger på, ikke er
fortolket.

Hvis byten er et bogstav, peger markøren på første byte i en
instruktion. Den næste byte indlæses og de to byte sættes sammen til
en instruktion.

Hvis byten er et tal eller symbol (punktum, komma osv.), peger
markøren på første byte i en talparameter. Der indlæses og gemmes
bytes indtil den indlæste byte ikke er et tal eller punktum. Når den
indlæste byte ikke er et tal eller punktum, konverteres de indlæste
bytes til et tal.

Se afviklingsdiagrammet for parseren i
figur\vref{fig:hpgl-parser-afvikling}. Parseren understøtter ikke
andre parametre end talparametre.

\begin{figure}[htbp]
  \centering
  \subfloat[Afviklingsdiagram for parserens instruktionsidentifikation.]{
    \includegraphics[width=.26\textwidth]{../brugere/kjaergaard/hpglparser-ins}
  }
  \qquad
  \subfloat[Afviklingsdiagram for parserens parameteridentifikation.]{
    \includegraphics[width=.64\textwidth]{../brugere/kjaergaard/hpglparser-param}
  }
  \caption{Afviklingsdiagrammer for HPGL-parseren}
  \label{fig:hpgl-parser-afvikling}
\end{figure}


\subsection{Relative og absolutte koordinater samt grafikenheder}
\label{sc:relativ-absolut}
\mnote{Christian Klim Hansen}

Indenfor HPGL bruger man relative og absolutte koordinater. Absolut
plotning indeholder to parametre, $X$ og $Y$. $X$ og $Y$ er absolutte
værdier, altså kan de ikke være negative, som måles enten i en
brugerdefineret enhed eller grafik enheder (0,025 mm). Absolut plot
bruges, når man vil flytte pennen til en bestemt koordinat set fra
origo $(0, 0)$. Der plottes kun en linie, når pennen er nede.

\snote{
  \includegraphics[width=\marginparwidth]{./img/relativ-absolut}
  \captionof{figure}{Eksempel på relativ og absolut linie}
  \label{fig:relativ-absolut}
}

Relativ plotning indeholder ligeledes to parametre, $x$ og $y$. $x$ og
$y$ er relative værdier til den nuværende position, altså kan de godt
være negative. Relativ plotning måles ligesom absolut. Relativ
plotning bruges, når man vil lave serie af linier i række, da man her
tager udgangspunkt i den forrige linies
slutpunkt. Figur\vref{fig:relativ-absolut} viser et eksempel på
relative og absolutte linier.

\subsection{Behandling af cirkel}
\label{sc:matematik-cirkel}

Ud fra parametrene kender vi cirklens radius $r$, kordevinklen $c$
samt startkoordinater $(x, y)$. Det første koordinat kan ud fra en
hurtig analyse derfor let findes:
\begin{align*}
  P_0(x, y) = (r, 0)
\end{align*}

\mnote{
  \includegraphics[width=\marginparwidth]{./img/cirkel}
  \captionof{figure}{Cirkel}
  \label{fig:cirkel-tegning}
}

Dette er tilfældet, da vinklen $w$ er $0\degree$.

Næste koordinat ligger i en vinkel $w$, som svarer til kordevinklen
$c$, altså har vi lagt en kordevinkel til de $0\degree$. Ved brug af
cosinus og sinus samt radius $r$ kan vi bestemme det næste koordinat:
\begin{align}
  P_1(x, y) &= \left( \cos(w) \times r, \sin(w) \times r \right) \Rightarrow \nonumber \\
  P_1(x, y) &= \left( \cos(c) \times r, \sin(c) \times r
  \right) \label{eq:8.1}
\end{align}
 
Denne formel kommer ud fra grundlæggende trigonometri:
\begin{align*}
  \cos(v) &= \frac{x}{r} \Rightarrow x = \cos(v)\times r \\
  \sin(v) &= \frac{y}{r} \Rightarrow y = \sin(v)\times r
\end{align*}
 
Formlen \vref{eq:8.1} kan omskrives, så den gælder et vilkårligt punkt
på cirkelperiferien:
\begin{align}
P_n(x, y)=(\cos(n\times c)\times r, \sin(n\times c)\times r)
\end{align}

Vi betragter en cirkel med en radius på 5cm og en kordevinkel på
$3\degree$. Første koordinat er således:
\begin{align*}
  P_0(x, y)&=(\cos(0\times 3\degree)\times 5 , \sin(0\times 3\degree)\times 5)=(5, 0) \\
\end{align*}

Vi ser, at dette passer i overensstemmelse med første
udsagn. Vha. ovenstående formel kan vi blot lægge en til $n$ hver gang
funktionen er udført. Dette skal den blive ved med indtil vinkel
overskrider $360\degree$. HPGL's standardkordevinkel er $5\degree$.


Der opstår dog et problem, hvis vinklen ikke går op i $360\degree$,
såsom vinklen $7\degree$. $51\times 7\degree = 357\degree \Rightarrow
\textup{rest} = 3\degree$. Overskrider vinklen de $360\degree$, har vi
to muligheder:
\begin{itemize} \firmlist
\item Funktionen afsluttes uden at slutte cirklen
\item Funktionen ændres, så optegningen fortsætter til udgangspunktet $P_0$
\end{itemize}

Afviklingsdiagrammet i figur\vref{fig:hpgl-cirkel-afvikling}
viser plotningsprocessen af en cirkel. Her fremgår det, at
HPGL tegner uanset om pennen er oppe eller nede, hvilket betyder, at
vi skal bruge en funktion til at hæve og sænke pennen. HPGL sender
"PU" (Pen Up), når pennen skal være oppe. Tilsvarende sender den en
"PD" (Pen Down), når der skal tegnes. Pennen starter i cirklens
centrum. Vi skal derfor sikre os, at pennen er hævet før den går til
første punkt $P_0$. Herefter bruger vi den generelle funktion til at
bestemme $(x, y)$-koordinaterne. Efter hver udført funktion lægges en
ekstra kordevinkel til vinklen indtil vinklen $w$ er større eller lig
$360\degree$. Herefter hæves pennen og flyttes tilbage til cirklens
centrum.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.9\textwidth]{./img/afviklingsdiagram-cirkel}
  \caption{Afviklingsdiagram for cirkelplot}
  \label{fig:hpgl-cirkel-afvikling}
\end{figure}


\section[Motorkontrol (med kø)]{Motorkontrol\footnote{Se rettelser til
    dette afsnit i afsnit\vref{ssc:rettelse-design}.}}


% Hvordan er motorkontrollen implementeret? Beskriv implementeringen
% kort.

\mnote{Kristian Kjærgaard}

Motorkontrollen har til opgave at flytte motorerne, så tegnehovedets
placering kan styres. Motorkontrollen sørger også for at time
motorerne, så der køres mellem to punkter i en lige linie med en given
hastighed.

Figur\vref{fig:i-motor-design} viser, hvordan motorkontrollen lægger
de tidspunkter, motorerne skal flyttes på, i en kø. Figuren viser
også, hvordan motorkontrollen periodisk tjekker, om et tidspunkt er
overskredet. Når et tidspunkt er overskredet, flyttes motorerne.

\begin{figure}[htbp]
  \centering
  \subfloat[Motorkontrollen lægger et tidspunkt i kø.]{
    \includegraphics[width=0.3\textwidth]{./img/i-motor-design-a}
  }
  \qquad
  \subfloat[Motorkontrollen tjekker om et tidspunkt er
  overskredet. Afviklingen af denne funktion styres af timeren og
  afbryder den almindelige afvikling.]{
    \includegraphics[width=0.3\textwidth]{./img/i-motor-design-b}
  }
  \caption{Afviklingsdiagrammer for funktioner i motorkontrollen}
  \label{fig:i-motor-design}
\end{figure}


I figur\vref{fig:la-behandling} ses et afviklingsdiagram for at
omsætte en linie til tidspunkter og lægge tidspunkterne i
kø. Tidspunkterne skal lægges i køen kronologisk med det tidligste
tidspunkt først, derfor er denne funktion kringlet.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=.75\textwidth]{./img/la-behandling}
  \caption{Afviklingsdiagram over afvikling af LA-instruktionen.}
  \label{fig:la-behandling}
\end{figure}


\section{Stepmotorstyring og løfter/sænker}

% Hvordan styres stepmotorerne? Superkort. Hvordan ser softwaren der
% styrer dem ud?

Stepmotorerne styres med kredsen L6208N, som indeholder en H-bro,
optokoblere og transistorer og kan holde til 52V. Et signal styrer
stepmotorens retning, mens en impuls får L6208N til at flytte motoren
et step.

Tegnehovedet sænkes ved at sende signal til den transistor, der åbner
for strømmen til magneten i tegnehovedet.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../master"
%%% End: 
